// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////////
package com.google.crypto.tink.aead.internal

import com.google.crypto.tink.aead.internal.InsecureNonceChaCha20Poly1305Base.macDataRfc8439
import com.google.crypto.tink.aead.internal.Poly1305.{MAC_KEY_SIZE_IN_BYTES, MAC_TAG_SIZE_IN_BYTES}

import java.nio.{ByteBuffer, ByteOrder}
import java.security.{GeneralSecurityException, InvalidKeyException}
import javax.crypto.AEADBadTagException

/**
 * Abstract base class for {@link InsecureNonceChaCha20Poly1305}, following RFC 8439
 * https://tools.ietf.org/html/rfc8439.
 *
 * <p>This implementation produces ciphertext with the following format: {@code actual_ciphertext ||
 * tag} and only decrypts the same format.
 */
abstract class InsecureNonceChaCha20Poly1305Base @throws[GeneralSecurityException](key: Array[Byte]) {
  final private var chacha20: InsecureNonceChaCha20Base = newChaCha20Instance(key, 1)
  final private var macKeyChaCha20: InsecureNonceChaCha20Base = newChaCha20Instance(key, 0)

  @throws[InvalidKeyException]
  private[internal] def newChaCha20Instance(key: Array[Byte], initialCounter: Int): InsecureNonceChaCha20Base

  /**
   * Encrypts {@code plaintext} with Poly1305 authentication based on {@code associatedData}.
   *
   * <p>Please note that nonce should be randomly generated by the caller hence keys need to be
   * rotated after encrypting a certain number of messages depending on the nonce size of the
   * underlying {@link InsecureNonceChaCha20Base}.
   *
   * @param nonce          specified by caller
   * @param plaintext      data to encrypt
   * @param associatedData associated authenticated data
   * @return ciphertext with the following format {@code actual_ciphertext || tag}
   */
  @throws[GeneralSecurityException]
  def encrypt(nonce: Array[Byte], plaintext: Array[Byte], associatedData: Array[Byte]): Array[Byte] = {
    if (plaintext.length > Integer.MAX_VALUE - MAC_TAG_SIZE_IN_BYTES) {
      throw new GeneralSecurityException("plaintext too long")
    }
    val ciphertext: ByteBuffer = ByteBuffer.allocate(plaintext.length + MAC_TAG_SIZE_IN_BYTES)
    encrypt(ciphertext, nonce, plaintext, associatedData)
    ciphertext.array
  }

  /**
   * Encrypts {@code plaintext} with Poly1305 authentication based on {@code associatedData}.
   *
   * <p>Please note that nonce should be randomly generated by the caller hence keys need to be
   * rotated after encrypting a certain number of messages depending on the nonce size of the
   * underlying {@link InsecureNonceChaCha20Base}.
   *
   * @param output         ciphertext buffer with the following format {@code actual_ciphertext || tag}
   * @param nonce          specified by caller
   * @param plaintext      data to encrypt
   * @param associatedData associated authenticated data
   */
  @throws[GeneralSecurityException]
  def encrypt(output: ByteBuffer, nonce: Array[Byte], plaintext: Array[Byte], associatedData: Array[Byte]): Unit = {
    if (output.remaining < plaintext.length + MAC_TAG_SIZE_IN_BYTES) {
      throw new IllegalArgumentException("Given ByteBuffer output is too small")
    }
    val firstPosition = output.position()
    chacha20.encrypt(output, nonce, plaintext)
    output.position(firstPosition)
    output.limit(output.limit - MAC_TAG_SIZE_IN_BYTES)
    var aad = associatedData
    if (aad == null) {
      aad = new Array[Byte](0)
    }
    val tag = Poly1305.computeMac(getMacKey(nonce), macDataRfc8439(aad, output))
    output.limit(output.limit + MAC_TAG_SIZE_IN_BYTES)
    output.put(tag)
  }

  /**
   * Decrypts {@code ciphertext} with the following format: {@code actual_ciphertext || tag}.
   *
   * @param nonce          specified by caller
   * @param ciphertext     with format {@code actual_ciphertext || tag}
   * @param associatedData associated authenticated data
   * @return plaintext if authentication is successful.
   * @throws GeneralSecurityException when ciphertext is shorter than tag size or when
   *                                  computed tag based on {@code ciphertext} and {@code associatedData} does not match the tag
   *                                  given in {@code ciphertext}.
   */
  @throws[GeneralSecurityException]
  def decrypt(nonce: Array[Byte], ciphertext: Array[Byte], associatedData: Array[Byte]): Array[Byte] = {
    decrypt(ByteBuffer.wrap(ciphertext), nonce, associatedData)
  }

  /**
   * Decrypts {@code ciphertext} with the following format: {@code actual_ciphertext || tag}.
   *
   * @param ciphertext     with format {@code actual_ciphertext || tag}
   * @param nonce          specified by caller
   * @param associatedData associated authenticated data
   * @return plaintext if authentication is successful
   * @throws GeneralSecurityException when ciphertext is shorter than tag size
   * @throws AEADBadTagException      when the tag is invalid
   */
  @throws[GeneralSecurityException]
  def decrypt(ciphertext: ByteBuffer, nonce: Array[Byte], associatedData: Array[Byte]): Array[Byte] = {
    if (ciphertext.remaining < MAC_TAG_SIZE_IN_BYTES) {
      throw new GeneralSecurityException("ciphertext too short")
    }
    val firstPosition = ciphertext.position()
    val tag = new Array[Byte](MAC_TAG_SIZE_IN_BYTES)
    ciphertext.position(ciphertext.limit - MAC_TAG_SIZE_IN_BYTES)
    ciphertext.get(tag)
    // rewind to read ciphertext and compute tag.
    ciphertext.position(firstPosition)
    ciphertext.limit(ciphertext.limit - MAC_TAG_SIZE_IN_BYTES)
    var aad = associatedData
    if (aad == null) {
      aad = new Array[Byte](0)
    }
    try Poly1305.verifyMac(getMacKey(nonce), macDataRfc8439(aad, ciphertext), tag)
    catch {
      case ex: GeneralSecurityException =>
        throw new AEADBadTagException(ex.toString)
    }
    // rewind to decrypt the ciphertext.
    ciphertext.position(firstPosition)
    chacha20.decrypt(nonce, ciphertext)
  }

  /** The MAC key is the first 32 bytes of the first key stream block */
  @throws[GeneralSecurityException]
  private def getMacKey(nonce: Array[Byte]) = {
    val firstBlock = macKeyChaCha20.chacha20Block(nonce, 0 /* counter */)
    val result = new Array[Byte](MAC_KEY_SIZE_IN_BYTES)
    firstBlock.get(result)
    result
  }
}

object InsecureNonceChaCha20Poly1305Base {
  /** Prepares the input to MAC, following RFC 8439, section 2.8. */
  private def macDataRfc8439(aad: Array[Byte], ciphertext: ByteBuffer) = {
    val aadPaddedLen =
      if (aad.length % 16 == 0) aad.length
      else aad.length + 16 - aad.length % 16
    val ciphertextLen = ciphertext.remaining
    val ciphertextPaddedLen =
      if (ciphertextLen % 16 == 0) ciphertextLen
      else ciphertextLen + 16 - ciphertextLen % 16
    val macData = ByteBuffer.allocate(aadPaddedLen + ciphertextPaddedLen + 16).order(ByteOrder.LITTLE_ENDIAN)
    macData.put(aad)
    macData.position(aadPaddedLen)
    macData.put(ciphertext)
    macData.position(aadPaddedLen + ciphertextPaddedLen)
    macData.putLong(aad.length)
    macData.putLong(ciphertextLen)
    macData.array
  }
}

